### 용어 설명
* 동시성
  * 여러 작업이 마치 동시에 실행되는 것처럼 관리되는 것

---

## 멀티프로세싱
여러 개의 프로세스(멀티프로세스)를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것이다.  
하드웨어 관점에서는 여러 개의 프로세서로 작업을 처리하는 것을 의미하기도 한다.

* 병렬 처리 가능
* 특정 프로세스의 메모리 등 문제가 발생해도 다른 프로세스 이용 가능: 높은 신뢰성

### 웹 브라우저
멀티프로세스 구조를 가지고 있다.

* 브라우저 프로세스
  * 주소표시줄, 북마크 막대, 뒤로/앞으로 가기 버튼
  * 네트워크 요청, 파일 접근 권한 담당
* 렌더러 프로세스
  * 웹 사이트가 보이는 부분의 모든 것 제어
* 플러그인 프로세스
  * 웹 사이트에서 사용하는 플러그인 제어
* GPU 프로세스
  * GPU를 이용하여 화면을 그리는 부분 제어

### IPC(Inter Process Communication)
IPC는 **프로세스끼리 데이터를 주고받고** 공유 데이터를 관리하는 메커니즘이다.  
IPC는 메모리가 완전히 공유되는 스레드보다는 속도가 떨어진다는 특징이 있다.

* **공유 메모리**
  * 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한을 부여하여 통신한다.
  * 매개체를 통해 데이터를 주고받는 것이 아닌, 메모리 자체를 공유하기 때문에 불필요한 데이터 복사 오버헤드가 발생하지 않아 IPC 중에서 가장 빠르다.
  * 같은 메모리 영역을 공유하기에 동기화가 필요하다.
* **파일**
  * 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터를 통해 통신한다.
* **소켓**
  * 네트워크 인터페이스를 통해 데이터를 전송하며, 예시로 TCP, UDP가 있다.
* **익명 파이프**
  * 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받는다.
  * 단방향 방식의 파이프를 만들어 작동한다.
  * 부모 - 자식 프로세스 간에만 사용이 가능하다.
  
  ![익명 파이프](3.3장%20프로세스와%20스레드(3.3.5%20~%203.3.8)/unnamed-pipe.png)
* **명명 파이프**
  * 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향/양방향(반이중) 파이프
  * 클라이언트/서버 통신을 위한 별도의 파이프를 제공하며, 여러 파이프를 동시에 사용할 수 있다.
  * 컴퓨터의 프로세스끼리 또는 다른 네트워크의 컴퓨터와도 통신이 가능하다.
  
  ![명명 파이프](3.3장%20프로세스와%20스레드(3.3.5%20~%203.3.8)/named-pipe.png)
* **메시지 큐**
  * 커널의 전역변수 형태 등 커널에서 전역적으로 관리
  * 다른 방식에 비해 사용 방법이 직관적이고 간단하다.
  * 공유 메모리를 통해 IPC를 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화때문에 기능 구현이 복잡해지는데, 이 대안으로 메시지 큐를 사용하기도 한다.
  * `masgget()`, `msgsnd()` 와 같은 C 함수를 통해 사용할 수 있다.

#### 익명파이프와 명명파이프 비교
**익명 파이프** 예시 코드  
부모에서 `pipe()` 를 통해 파이프 생성 후 자식 - 부모 프로세스 간 통신을 진행한다.
``` C
#include <stdio.h>

/* The index of the "read" end of the pipe */
#define READ 0

/* The index of the "write" end of the pipe */
#define WRITE 1

char *phrase = "Stuff this in your pipe and smoke it";

main () {
  int fd[2], bytesRead;

  char message [100]; /* Parent process message buffer */

  pipe ( fd ); /*Create an unnamed pipe*/
  
  if ( fork ( ) == 0 ) {
    /* Child Writer */
    close (fd[READ]); /* Close unused end*/
    write (fd[WRITE], phrase, strlen ( phrase) +1); /* include NULL*/
    close (fd[WRITE]); /* Close used end*/
    printf("Child:  Wrote '%s' to pipe!\n", phrase);
  } else {
    /* Parent Reader */
    close (fd[WRITE]); /* Close unused end*/
    bytesRead = read ( fd[READ], message, 100);
    printf ( "Parent: Read %d bytes from pipe: %s\n", bytesRead, message);
    close ( fd[READ]); /* Close used end */
  } 
}
```

**명명 파이프** 예시 코드  
`mknod` utility, `mknod()` system call을 통해서 명명 파이프를 생성한다.

쉘에서 생성하는 경우
``` 
$ mknod mypipe p
```
C 프로그램 내부에서 생성하는 경우
``` C
mknod ( "mypipe", SIFIFO, 0 );
```
명명 파이프를 생성하면, 파일시스템에 특정 파일이 생긴 것처럼 보이게 된다.
``` 
$ ls -l mypipe
prw-r—r-- 1 srs users 0 Nov 6 22:28 mypipe
```
이렇게 만들어진 명명 파이프의 사용을 위해서는, 파일같이 `open()`, `read()`, `write()` 등의 함수를 통해 사용할 수 있다.  
open 시, `O_NONBLOCK` 또는 `O_NDELAY`를 지정하지 않으면 타 프로세스가 읽기/쓰기를 위해 open할 때까지 block된 상태로 남아있다.  
또한 해당 플래그를 지정하면 write를 위해 open할 때엔 성공하나, read를 위해 open할 때에는 실패한다.

``` C
/* Writer */
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

char * phrase = "Stuff this in your pipe and smoke it";

int main () {
  int fd1; 
  fd1 = open ( "mypipe", O_WRONLY ); 
  write (fd1, phrase, strlen ( phrase)+1 ); 
  close (fd1);
}

/* Reader */
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main () {
  int fd1;
  char buf [100];

  fd1 = open ( "mypipe", O_RDONLY ); 
  read ( fd1, buf, 100 ); 
  printf ( "%s\n", buf ); 
  close (fd1);
} 
```

## 스레드와 멀티스레딩
### 스레드
스레드는 프로세스의 실행 가능한 가장 작은 단위다. 프로세스는 여러 스레드를 가질 수 있다.  
**프로세스**는 코드, 데이터, 스택, 힙을 각각 생성하지만  
**스레드**는 코드, 데이터, 힙은 스레드끼리 공유하며, 그 외의 영역만 각각 생성된다.

### 멀티스레딩
프로세스 내 작업을 여러 개의 스레드로 처리한다.
* 효율성이 높다.
* 프로세스에 비해 훨씬 적은 리소스를 소비한다.  
* 한 스레드가 `blocked` 되어도 다른 스레드는 `running` 상태일 수 있기 때문에 빠르게 처리할 수 있다.  
* 동시성에도 큰 장점이 있다.  
* 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 프로세스에 영향을 줄 수 있다.

<br/>

예시로 브라우저의 렌더러 프로세스 내 작업을 들 수 있다.
* 메인 스레드
  * HTML 파싱 후 DOM 변환
  * CSS 파싱 후 각 DOM 노드에 계산된 스타일 확정
  * 레이아웃 트리 생성
* 워커 스레드
  * 보조 역할을 함
* 컴포지터 스레드
  * 레이어 트리, 페인터 순서 정보를 받아 레이어를 타일 형태로 나누고, 레스터 스레드에 전달
  * 레이어 합성
* 레스터(화면 픽셀 변환) 스레드
  * 각 타일을 픽셀로 변환


## 공유 자원과 임계 영역
### 공유 자원
시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수  
두 개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황: **경쟁 상태(race condition)**

### 임계 영역
둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 결과가 달라질 수 있는 코드 영역  

임계 영역의 해결을 위한 방법 세 가지
* 뮤텍스
* 세마포어
* 모니터

임계 영역의 해결 조건
* 상호 배제
  * 한 프로세스/스레드가 임계 영역에 들어갔을 때 다른 프로세스/스레드는 들어갈 수 없다.
* 한정 대기
  * 어떤 프로세스/스레드도 임계 영역에 진입하지 못하여 무한 대기하지 않아야 한다. (기아 상태 해결)
* 융통성
  * 임계 구역이 비어있다면 임계 영역 외부의 어떤 프로세스/스레드도 방해받지 않고 임계 구역에 들어와 작업할 수 있어야 한다. (교착 상태 해결)

#### 뮤텍스
공유 자원을 `lock()`, `unlock()`을 통해 잠그고 해제하는 잠금 매커니즘을 가진다.  
뮤텍스는 잠금 혹은 잠금 해제라는 상태만을 가진다.  
조건 변수를 가진다. 즉, 조건을 만족할 때까지 sleep하게 할 수 있다.  
이는 스레드를 반복적으로 일정 시간 재웠다가 깨워 조건을 확인하는 비효율성을 해결할 수 있다.

#### 세마포어
일반화된 뮤텍스이며, 정수 값과 `wait()`, `signal()` 함수를 통해 관리한다.  
조건 변수가 없고, 프로세스나 스레드가 세마포어 값을 수정할 때 다른 프로세스나 스레드는 동시에 세마포어 값을 수정할 수 없다.  
상호배제를 명시적으로 구현해야 한다.
* 바이너리 세마포어
  * 0/1의 값을 가지는 세마포어로 뮤텍스와 유사하다.
  * 하지만, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 메커니즘이다.
  * 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 메커니즘이라는 것에서 차이가 존재한다.
    * 전화가 오면 노래가 중지되고 통화 작업 인터페이스가 등장하는 것과 유사하다.
* 카운팅 세마포어
  * 여러 개의 값을 가지며, 여러 자원에 대한 접근을 제어할 수 있다.

#### 모니터
둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고, 해당 접근에 대한 인터페이스만 제공한다.  
모니터큐를 통해 공유 자원에 대한 작업을 순차적으로 처리한다.  
세마포어보다 구현하기 쉬우며 상호 배제는 자동으로 이루어진다.  
Java의 `synchronized` 키워드를 사용하여 만들 수 있다.

## 교착상태 (deadlock)
두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 교착상태의 원인
* 상호 배제
  * 자원은 한 프로세스가 독점한다.
* 점유 대기
  * 특정 프로세스가 점유한 자원을 얻기 위해 요청 및 대기한다.
* 비선점
  * 다른 프로세스의 자원을 강제로 가져올 수 없다.
* 환형 대기
  * 각 프로세스가 순환적으로 서로가 원하는 자원을 가지고 있다.

### 교착 상태의 해결 방법
1. 조건이 성립하지 않도록 자원 할당을 설계한다.
2. 교착 상태 가능성이 없을 때만 자원을 할당하고, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 **은행원 알고리즘**을 사용한다.
3. 교착 상태가 발생하면 사이클이 있는지 찾고, 이와 관련된 프로세스를 한 개씩 지운다.
4. 교착 상태는 드물게 일어나고, 처리 비용이 더 크기 때문에 교착 상태 발생 시 사용자가 **작업을 종료**한다.
   현대 운영체제는 이 방법을 선택했다. (ex. 응답없음 발생하는 경우 교착상태일 수 있다.)

### 은행원 알고리즘(Banker's Algorithm)
자원의 할당 여부를 결정하기 전, 미리 모든 요청을 수행 가능한지 시뮬레이션하여 안전 여부를 검사한다.  
자원 요청 사항을 충족시켜도 시스템이 안전 상태에 있다면 자원 할당을 허용한다.  
**불안전한 상태가 무조건 교착상태인 것은 아니**지만, 그렇게 갈 가능성이 있기 때문에 안전한 경우에만 자원을 할당한다.

