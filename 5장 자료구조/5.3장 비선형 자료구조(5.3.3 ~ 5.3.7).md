## 힙 (Heap)
힙은 **완전 이진 트리** 기반의 자료구조이며, 최소힙과 최대힙 두 가지가 있다.  
(완전 이진 트리: 왼쪽부터 완전히 채워진 이진 트리)

* 최대 힙
  * 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 **커야** 한다.
  * 이와 같은 특징은 자식 노드에 대해서도 재귀적으로 이루어진다.
* 최소 힙
  * 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 **작아야** 한다.
  * 이와 같은 특징은 자식 노드에 대해서도 재귀적으로 이루어진다.

힙에는 어떠한 값이 들어와도 특정 힙의 규칙을 지키도록 만들어져있다. 즉, 우선순위가 높은 노드가 항상 루트 노드에 존재한다.  

힙의 포인트는 우선순위가 높은 순서대로 뽑을 수 있다는 것에 있다.  
이러한 특징 때문에 형제 간 관계는 고려되지 않으며 부모-자식간의 관계가 중요하다.  
이러한 정렬 상태를 **반 정렬 상태**, **느슨한 정렬 상태** 라고 한다.  

![힙](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/heap.png)

### 최대 힙의 삽입
힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.  
이 새로운 노드를 부모 노드들과의 크기를 비교하며 스왑하는 과정을 통해 힙의 성질을 만족시킨다.

![힙의 삽입](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/heap-insert.png)

### 최대 힙의 삭제
최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제되고, 마지막 노드와 루트 노드를 스왑한다.  
그 이후 자식 노드와 비교하며 스왑의 과정을 통해 다시 힙의 성질을 만족시킨다.

### 예제
#### C++
`priority_queue` 가 Heap 자료구조로 구현되어 있다.  
기본 값은 최대 힙이며, `greater<자료형>` 을 통해 최소 힙으로 만들 수 있다.
``` C++
priority_queue<int> maxHeap;
priority_queue<int, vector<int>, greater<int>> minHeap;
```

#### Java
`PriorityQueue` 가 Heap 자료구조로 구현되어 있다.  
기본 값은 최대 힙이며, 다음과 같이 사용할 수 있다.  
``` Java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>();
PriorityQueue<Integer> minHeap = new PriorityQueue<>(Collections.reverseOrder());
```

## 우선순위 큐 (Priority Queue)
우선순위 대기열이라고도 하며, 대기열에서 우선 순위가 높은 요소가 먼저 제공되는 자료 구조다.  
힙을 기반으로 구현된다.

![우선순위 큐](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/priority-queue.png)

## 맵 (Map)
특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료구조다.  
**레드 블랙 트리** 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬된다.  

### map(C++) / TreeMap(Java)
* 레드 블랙 트리 기반이며, 정렬을 보장한다.
* 해시 충돌에서부터 안전하다.
* 비교적으로 더 적은 메모리를 사용한다.
* key의 데이터 타입이 복잡하다면 map을 권장한다.
* 탐색, 삽입 시간: `O(log n)`
![레드 블랙 트리](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/red-black-tree.png)

### unordered_map(C++) / HashMap(Java)
* 해시 테이블 기반이며, 정렬을 보장하지 않는다.
* 탐색, 삽입 시간: `O(1)`
![unordered_map](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/unordered-map.png)

### C++ 에서의 맵
* `clear()` : 모든 요소 삭제
* `size()` : 맵의 크기
* `erase()` : 인자에 해당하는 키와 키에 매핑된 값 삭제

순회 시 key는 `first` , value는 `second` 로 확인 가능하다.

``` C++
for (auto c : m) {
  cout << c.first << " : " << c.second << '\n';
}
```

## 셋 (Set)
특정 순서에 따라 중복되는 요소 없이 고유한 요소를 저장하는 컨테이너다.  
`set` 과 `unordered_set` 이 있는 등, map과 비슷한 특징을 가진다.

## 해시 테이블 (Hash Table)
무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블이다.  
삽입, 삭제, 탐색 시 평균적으로 `O(1)` 의 시간복잡도를 가진다.  
`unordered_map` 으로 구현한다.

![해시 테이블](5.3장%20비선형%20자료구조(5.3.3%20~%205.3.7)/hash-table.png)