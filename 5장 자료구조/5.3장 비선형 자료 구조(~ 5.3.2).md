# 5.3 비선형 자료 구조

비선형 자료 구조 : 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조

## 5.3.1 그래프

그래프 : `정점(vertex)`과 그 정점을 연결하는 `간선(edge)`으로 이루어진 자료구조

- outdegree : 정점v로부터 나가는 간선
- indegree : 정점v로 들어오는 간선
- 가중치 : 간선과 정점 사이에 드는 비용

### **그래프의 종류**

- `무향 그래프(Undirected Graph)` : 양방향 그래프
- `유향 그래프, 방향 그래프(Directed Graph)` : 하나의 간선이 하나의 방향만을 표현
- `가중치 그래프(Weighted Graph)` : 관계의 정도를 수치로 표현
- 연결 그래프(Connected Graph) **:** 모든 정점에 대해 항상 경로를 가지는 그래프
- 완전 그래프(Complete Graph) **:** 모든 정점에 가능한 모든 간선을 가진 그래프
- 사이클 없는 유향, 방향 그래프(DAG, Directed Acyclic Graph) : 순환되지 않는 방향 그래프, 각 간선의 끝을 따라가면 원래의 정점으로 돌아오지 않음

## 5.3.2 트리

트리 : 정점과 간선으로 이루어져있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합

트리로 이루어진 집합을 숲 이라고 함

### 트리의 특징

<img src="https://github.com/user-attachments/assets/14d38050-b385-4d4c-a446-9b458324e010" width="700px" />


1. 부모 자식 계층 구조를 갖는다.
2. V(노드 수) - 1 = E(간선 수)라는 특징이 있다.
3. 임의의 두 노드 사이의 경로는 반드시 존재한다.

### 트리의 구성

- `루트 노드` : 가장 위에 있는 노드
- `내부 노드` : 로트 노드와 내부 노드 사이에 있는 노드
- `리프 노드` : 자식 노드가 없는 노드

### 트리의 높이와 레벨

<img src="https://github.com/user-attachments/assets/22024430-1eca-407c-be4d-f6badd05ee8a" width="700px" />

- `깊이(Depth)`: 루트 노드로부터 특정 노드까지 최단 거리로 갔을 때의 거리 (4번 노드 깊이는 2)
- `높이(Height)`: 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리 (그림에서는 3)
- 레벨(Level): 특정 깊이를 가지는 노드의 집합 (보통 깊이 + 1)
- 서브트리(Subtree): 트리 내 부분 집합이다. (ex. 5,6,7은 서브트리이다)

## 이진트리

자식의 노드 수가 2개 이하인 트리

- 정이진 트리: 자식 노드가 0 or 2개인 이진 트리
- `완전 이진 트리`: 왼쪽부터 채워진 이진 트리
- 변질 이진 트리: 자식 노드가 1개뿐인 이진 트리
- `포화 이진 트리`: 모든 노드가 꽉 찬 이진 트리
- `균형 이진 트리`: 왼쪽과 오른쪽 노드 높이 차이가 1 이하인 이진 트리

### 이진 탐색 트리 (BST, **Binary Search Tree**)

- 노드 왼쪽 노드 값보다 `작은 값`의 노드만 포함
- 노드 오른쪽 : 노드 값보다 `큰 값`의 노드만 포함
- 검색에 용이함
- 시간복잡도
    - 탐색에 소요되는 시간 `O(log n)`
    - 연결리스트의 경우 입력, 삭제 `O(1)`
    - 최악의 경우 `O(n)`

**최악의 경우 O(n)의 시간이 걸리는 이유**

이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있다. 완전히 한쪽으로 치우쳐진 변질 이진 트리와 유사한 경우에는 루트노트에서 출발해 모든 노드를 확인해야하기 때문에 O(n)의 시간 복잡도를 가진다.

### AVL트리

발명자 이름인 Adelson-Velsky and Landis에서 따왔다고 한다.

위 이진 참색 트리의 최악의 경우가 되는것을 방지하고자 `스스로 균형을 잡는 이진 탐색 트리`이다.

<img width="700" src="https://github.com/user-attachments/assets/44ce9460-1345-40e4-9dee-79e940fa778e">

- 왼쪽, 오른쪽 서브 트리의 높이차이가 `최대 1`
- 어떤 시점에서 높이 차이가 1보다 커지면 `회전(rotation)`을 통해 균형을 잡는다.
- 시간복잡도
    - 탐색, 삽입, 삭제 모두 `O(log n)`

균형도: `좌특 노드 높이 - 우측 노드 높이`

<img width="700" src="https://github.com/user-attachments/assets/cfd0f3be-782e-4e51-94cf-2ed0fbef8096">


### 레드 블랙 트리

균형 이진 탐색 트리로, 탐색, 삽입, 삭제 모두 `O(log n)`

각 노드는 빨간색, 검은색 색상을 나타내는 `추가 비트`를 저장 (삽입 및 삭제중 균형 유지에 사용)

C++ STL의 set, multiset, map, multimap 이 레드 블랙 트리를 이용하여 구현 됨

**규칙**

- 모든 리프 노드와 루트 노드는 블랙
- 레드 노드의 자식 노드는 언제나 모두 블랙
- 특정 노드에서 후손 노드로 가는 경로는 동일한 수의 검정색 노드가 존재한다.
  <img width="600" src="https://github.com/user-attachments/assets/f39f9892-0a61-437a-a1d1-bb98aefdc577">

<aside>
💡

**Red-Black 트리보다 AVL트리가 더 엄격하게 균형을 잡는다.**

Red-Black 트리가 노드의 재배치 가능성이 더 낮음 (삽입 삭제 성능이 더 좋음)

- 삽입 삭제가 많은 경우 - 레드 블랙 트리
- 연산이 적고 탐색이 많은 경우 - AVL 트리
</aside>

---
Ref

Avl - [https://www.youtube.com/watch?v=9BiHgy40NNE](https://www.youtube.com/watch?v=9BiHgy40NNE)

레드 블랙 트리 - [https://www.youtube.com/watch?v=FPc36I2vzjQ](https://www.youtube.com/watch?v=FPc36I2vzjQ)
